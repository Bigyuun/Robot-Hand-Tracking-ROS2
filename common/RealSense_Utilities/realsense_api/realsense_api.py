import numpy as np
import pyrealsense2 as rs
import json
import cv2
from threading import Thread
from multiprocessing.pool import ThreadPool
# from realsense_api.post_processing.option import OptionType
from RealSense_Utilities.realsense_api.post_processing.options import \
    DecimationOptions, SpatialOptions, TemporalOptions, HoleFillingOptions, OptionType

import os, sys

# TODO:
#   - Create a method for loading the json options that are generated by the realsense viewer
#   - Create a method for displaying the options that are currently set
#   - Add any remaining stream types into the get data method such as confidence
#   - Add any other post processing filters that are missing

# Links that I thought would be useful later:
#   https://intelrealsense.github.io/librealsense/python_docs/_generated/pyrealsense2.threshold_filter.html?highlight=process
#   https://github.com/IntelRealSense/librealsense/issues/6902
#   https://github.com/IntelRealSense/librealsense/issues/10078

def frame_to_np_array(frame, colorize_depth=False):
    # Create colorized depth frame
    if colorize_depth:
        colorizer = rs.colorizer()
        frame_as_image = np.asanyarray(colorizer.colorize(frame).get_data())
        return frame_as_image
    frame_as_image = np.asanyarray(frame.get_data())
    return frame_as_image


def find_realsense():
    realsense_ctx = rs.context()
    connected_devices = []
    serial_number = []
    for i in range(len(realsense_ctx.devices)):
        detected_camera = realsense_ctx.devices[i]
        connected_devices.append(detected_camera)
        serial_number.append(detected_camera.get_info(rs.camera_info.serial_number))

    return zip(serial_number, connected_devices)


def mediapipe_detection(image, model):
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # COLOR CONVERSION BGR 2 RGB
    image.flags.writeable = False  # Image is no longer writeable
    results = model.process(image)  # Make prediction
    image.flags.writeable = True  # Image is now writeable
    image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)  # COLOR CONVERSION RGB 2 BGR
    return image, results


class RealSenseCamera:
    def __init__(self,
                 depth_stream_width=848, depth_stream_height=480,
                 color_stream_width=640, color_stream_height=480,
                 depth_stream_fps=90, color_stream_fps=60,
                 device=None, adv_mode_flag=False, device_type='d455',
                 mp_lock=None, disable_color_auto_exposure=False):

        self.device = device
        self.device_type = device_type

        self.current_timestamp = 0

        self.colored_depthmap = None
        self.color_image = None
        self.depth_image = None

        # Resolution attributes
        self.depth_stream_width = depth_stream_width
        self.depth_stream_height = depth_stream_height
        self.color_stream_width = color_stream_width
        self.color_stream_height = color_stream_height

        self.depth_stream_fps = depth_stream_fps
        self.color_stream_fps = color_stream_fps

        # Data attributes that will be set with get_data()
        self.frameset = None
        self.depth_frame = None
        self.color_frame = None
        self.infrared_frame = None
        self.color_intrinsics = None
        self.depth_intrinsics = None
        self.depth_scale = None
        self.camera_matrix = None
        self.dist_coeffs = None

        # Holds the frameset after it has undergone filtering 
        self.filtered_frameset = None

        # Aligned frame holders
        self.depth_frame_aligned = None
        self.color_frame_aligned = None

        # Post Processing Filter attributes with default values
        # https://dev.intelrealsense.com/docs/post-processing-filters

        self.decimation: DecimationOptions = DecimationOptions()
        self.spatial: SpatialOptions = SpatialOptions()
        self.temporal: TemporalOptions = TemporalOptions()
        self.hole_filling: HoleFillingOptions = HoleFillingOptions()

        # Decimation filter attribute 
        self.decimation_magnitude = 3

        # Spatial filter attributes
        self.spatial_magnitude = 2
        self.spatial_smooth_alpha = 0.4
        self.spatial_smooth_delta = 4
        self.spatial_holes_fill = 0

        # Temporal filter attributes
        self.temporal_smooth_alpha = 0.1
        self.temporal_smooth_delta = 20
        self.persistency_index = 5

        # Holes Filling filter attribute
        self.hole_filling_param = 1

        self.decimation_filter = rs.decimation_filter()
        self.decimation_filter.set_option(
            rs.option.filter_magnitude,
            self.decimation_magnitude
        )

        self.spatial_filter = rs.spatial_filter()
        self.spatial_filter.set_option(
            rs.option.filter_magnitude,
            self.spatial_magnitude
        )
        self.spatial_filter.set_option(
            rs.option.filter_smooth_alpha,
            self.spatial_smooth_alpha
        )
        self.spatial_filter.set_option(
            rs.option.filter_smooth_delta,
            self.spatial_smooth_delta
        )
        self.spatial_filter.set_option(
            rs.option.holes_fill,
            self.spatial_holes_fill
        )

        self.temporal_filter = rs.temporal_filter()
        self.temporal_filter.set_option(
            rs.option.filter_smooth_alpha,
            self.temporal_smooth_alpha
        )
        self.temporal_filter.set_option(
            rs.option.filter_smooth_delta,
            self.temporal_smooth_delta
        )
        self.temporal_filter.set_option(
            rs.option.holes_fill,
            self.persistency_index
        )

        self.hole_filling_filter = rs.hole_filling_filter()
        self.hole_filling_filter.set_option(
            rs.option.holes_fill,
            self.hole_filling_param
        )

        self.depth_to_disparity = rs.disparity_transform(True)
        self.disparity_to_depth = rs.disparity_transform(False)

        # json profile
        script_dir = os.path.dirname(os.path.abspath(__file__))
        if self.device_type == 'd455':
            config_file_path = os.path.join(script_dir, 'd455.json')
            self.jsonObj = json.load(open(config_file_path))
            # self.jsonObj = json.load(open("./d455.json"))
        elif self.device_type == 'd405':
            config_file_path = os.path.join(script_dir, 'd405.json')
            self.jsonObj = json.load(open(config_file_path))
            # self.jsonObj = json.load(open("./d405_0321.json"))
        elif self.device_type == 'd415':
            self.jsonObj = json.load(open("./d415_0131.json"))

        print(f"{self.device_type} is selected...")

        self.pipeline = rs.pipeline()
        config = rs.config()
        config.enable_device(self.device.get_info(rs.camera_info.serial_number))

        config.enable_stream(rs.stream.depth,
                             self.depth_stream_width, self.depth_stream_height,
                             rs.format.z16, self.depth_stream_fps)

        config.enable_stream(rs.stream.color,
                             self.color_stream_width, self.color_stream_height,
                             rs.format.bgr8, self.color_stream_fps)

        config.enable_stream(rs.stream.infrared,
                             rs.format.y8,
                             self.depth_stream_fps)

        self.profile = self.pipeline.start(config)

        self.sensor = self.device.query_sensors()

        self.mp_lock = mp_lock

        # Get depth scale
        depth_sensor = self.profile.get_device().first_depth_sensor()
        depth_sensor.set_option(rs.option.emitter_enabled, 1)
        self.depth_scale = depth_sensor.get_depth_scale()

        self.color_intrinsics = self.profile.get_stream(rs.stream.color).as_video_stream_profile().get_intrinsics()
        self.depth_intrinsics = self.profile.get_stream(rs.stream.depth).as_video_stream_profile().get_intrinsics()
        self.camera_matrix = np.array(
            [[self.color_intrinsics.fx, 0, self.color_intrinsics.ppx],
             [0, self.color_intrinsics.fy, self.color_intrinsics.ppy],
             [0, 0, 1]],
            dtype=np.float64)
        self.dist_coeffs = np.array([self.color_intrinsics.coeffs], dtype=np.float64)

        if adv_mode_flag:
            self.adv_mode()

        if disable_color_auto_exposure:
            color_sensor = self.sensor[1]
            color_sensor.set_option(rs.option.auto_exposure_priority, 0)
            color_sensor.set_option(rs.option.enable_auto_exposure, 0)

    def __iter__(self):
        return self.device.get_info(rs.camera_info.serial_number)

    def __del__(self):
        # self.stop()
        pass

    # def get_options(self):
    def get_data(self):
        if self.mp_lock is not None:
            self.mp_lock.acquire()

        frameset = self.pipeline.wait_for_frames()
        try:
            self.current_timestamp = frameset.get_timestamp()
            # self.frameset.keep()
            self.depth_frame = frameset.get_depth_frame()
            self.color_frame = frameset.get_color_frame()
            self.infrared_frame = frameset.first(rs.stream.infrared)

            self.frameset = frameset

        except RuntimeError as e:
            print(str(self.device.get_info(rs.camera_info.serial_number)) + " camera can't polling frame")

        if self.mp_lock is not None:
            self.mp_lock.release()

    def get_aligned_frames(self, frameset, aligned_to_color=False, aligned_to_depth=False):
        if aligned_to_color:
            align_to = rs.stream.color
            align = rs.align(align_to)
            frameset = align.process(frameset)

        if aligned_to_depth:
            align_to = rs.stream.depth
            align = rs.align(align_to)
            frameset = align.process(frameset)

        self.depth_frame_aligned = frameset.get_depth_frame()
        self.color_frame_aligned = frameset.get_color_frame()
        self.frameset = frameset

    def filter_depth_data(self,
                          enable_decimation=False,
                          enable_spatial=False,
                          enable_temporal=False,
                          enable_hole_filling=False):

        """Apply a cascade of filters on the depth frame"""
        depth_to_disparity = rs.disparity_transform(True)
        disparity_to_depth = rs.disparity_transform(False)

        frameset = self.frameset
        # DECIMATION FILTER
        if enable_decimation:
            decimation = rs.decimation_filter()
            decimation.set_option(
                rs.option.filter_magnitude,
                self.decimation.options[OptionType.MAGNITUDE].option_value
            )
            frameset = decimation.process(frameset).as_frameset()

        # depth to disparity
        frameset = depth_to_disparity.process(frameset).as_frameset()

        # SPATIAL FILTER
        if enable_spatial:
            spatial = rs.spatial_filter()
            spatial.set_option(
                rs.option.filter_magnitude,
                self.spatial.options[OptionType.MAGNITUDE].option_value
            )
            spatial.set_option(
                rs.option.filter_smooth_alpha,
                self.spatial.options[OptionType.SMOOTH_ALPHA].option_value
            )
            spatial.set_option(
                rs.option.filter_smooth_delta,
                self.spatial.options[OptionType.SMOOTH_DELTA].option_value
            )
            spatial.set_option(
                rs.option.holes_fill,
                self.spatial.options[OptionType.HOLE_FILLING].option_value
            )
            frameset = spatial.process(frameset).as_frameset()

        # TEMPORAL FILTER
        if enable_temporal:
            temporal = rs.temporal_filter()
            temporal.set_option(
                rs.option.filter_smooth_alpha,
                self.temporal.options[OptionType.SMOOTH_ALPHA].option_value
            )
            temporal.set_option(
                rs.option.filter_smooth_delta,
                self.temporal.options[OptionType.SMOOTH_DELTA].option_value
            )
            temporal.set_option(
                rs.option.holes_fill,
                self.temporal.options[OptionType.PERSISTENCY_INDEX].option_value
            )
            frameset = temporal.process(frameset).as_frameset()

        # disparity to depth
        frameset = disparity_to_depth.process(frameset).as_frameset()

        # HOLE FILLING
        if enable_hole_filling:
            hole_filling = rs.hole_filling_filter()
            hole_filling.set_option(
                rs.option.holes_fill,
                self.hole_filling.options[OptionType.HOLE_FILLING].option_value
            )
            frameset = hole_filling.process(frameset).as_frameset()

        self.filtered_frameset = frameset

    def adv_mode(self):
        json_string = str(self.jsonObj).replace("'", '\"')

        advnc_mode_arg = rs.rs400_advanced_mode(self.device)
        advnc_mode_arg.load_json(json_string)

    def stop(self):
        self.pipeline.stop()
